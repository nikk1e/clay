<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Type" content="application/xhtml+xml">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title></title>
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Open+Sans:400,300,700|Inconsolata" />
<link rel="stylesheet" href="http://yui.yahooapis.com/pure/0.5.0/pure-min.css"/>

<!--[if lte IE 8]>
    <link rel="stylesheet" href="css/layouts/side-menu-old-ie.css">
<![endif]-->
<!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="css/layouts/side-menu.css">
<!--<![endif]-->
<link rel="stylesheet" href="css/clay.css"/>
<style type="text/css">
/* stuff here */

figcaption {
	position: absolute;
	top: 0;
	left: -170px;
	width: 150px;
	font-style: italic;
	text-align: right;
	color: rgba(0,0,0,0.5);
	font-family: serif;
}
figcaption:before {
	width: 35%;
	margin-left: 65%;
	border-top: 1px solid #edece4;
	display: block;
	content: '';
	margin-bottom: 5px;
}
figure {
	position: relative;
	clear: both;
}
td.empty {
	height: 20px;
	border-bottom: 1px dotted #cbcbcb;
}
hr {
	border-top: 1px solid #edece4;
	border-bottom: 0;
	border-left: 0;
	border-right: 0;
}
section:after {
	width: 16%;
	margin-left: 38%;
	border-top: 1px solid #edece4;
	display: block;
	content: '';
	margin-top: 50px;
	margin-bottom: 50px;
}
pre[class*='lang-javascript'] {
	background-color: #2A2C39;
}
pre[class*='lang-javascript'] > code {
	color: #E9E9EB;
}

textarea.hiddenTextArea {
	width: 100%;
	height: 50px;
	opacity: 0;
	position: absolute;
	left: -3000px;
}
</style>
</head>
<body>
<div id="layout">
    <!-- Menu toggle -->

    <div id="main">
	</div>
</div>
<script type="text/javascript" src="js/friar.js"></script>
<script type="text/javascript" src="js/cube.js"></script>
<script type="text/javascript">

var DOM = Friar.DOM, 
    createClass = Friar.createClass,
    Model = Cube.Model,
    parse = Cube.parse;

var KEY_PREFIX = 'clay:';
var reKey = /clay:/;

function keyToId(key) {
	return KEY_PREFIX + key.toString(36);
}

function idToKey(id) {
	return parseInt(id.slice(KEY_PREFIX.length), 36);
}

var Table = createClass({
	render: function() {
		var token = this.props;
		var rows = token.rows;
		var alignments = token.alignments;

		//TODO: give the rows keys within the table
		function renderRow(row, type, alignments) {
			return DOM.tr({id: keyToId(token.key) + '.' + row.key.toString(36)},
				row.cells.length > 0 ? row.cells.map(function(c,i) {
					return DOM[type]({style: (alignments[i] || {})}, c); //TODO (c should be spans)
				}) : [DOM.td({className: 'empty', colSpan: alignments.length},' ')]);
		}

		return DOM.table({id: keyToId(token.key),  
						  className: 'pure-table pure-table-bordered'}, 
			DOM.thead({},[renderRow(rows[0], 'th', alignments)]), 
			DOM.tbody({},rows.slice(1).map(
				function(row) { return renderRow(row, 'td', alignments); })));
	}
});

function fixSpaces(str) {
	return str.replace(/^ +|  +| +(?=\n|$)/, function(m,a,b) {
				return Array(m.length + 1).join('\u00A0');
			});
}

// render model to array of Friar components
function renderToFriar(model) {
	var rendered = [];
	var tokens = model.cells;
	var index = 0;
	var token;
	
	function getToken() {
		return token = tokens[index++];
	}

	function ungetToken() {
		return token = tokens[(--index)-1];
	}

	function renderSpans(item) {
		if (item.spans.length === 0) {
			return [DOM.text('\u00A0')]; //id: keyToId(token.key)
		}
		return item.spans.map(function(c) {
			return DOM.text(fixSpaces(c.text)); //TODO: assmuing everything is text
		});
	}

	function renderRow(type, alignments) {
		return DOM.tr({id: keyToId(token.key)},token.values.map(function(c,i) { //
			return DOM[type]({style: (alignments[i] || {})}, c); //TODO (c should be spans)
		}));
	}

	function renderCode(lang) {
		var items = [];
		var langClass;
		while (token && token.type === 'code' && !token.result && token.lang === lang) {
			var props = {id: keyToId(token.key)};//TODO: add key
			if (token.lang) langClass = props.className = 'lang-' + token.lang
			items.push(DOM.code(props,fixSpaces(token.text))); 
			getToken();
		}
		ungetToken();
		return [DOM.pre({className: langClass}, items)];
	}

	function renderList(listType, itemType) {
		var items = [];
		while (token && token.type === itemType) {
			items.push(DOM.li({id: keyToId(token.key)},renderSpans(token))); //TODO: add key
			getToken();
		}
		ungetToken();
		return [DOM[listType]({}, items)];
	}

	function renderFigure() {
		var f = token;
		return [DOM.figure({id: keyToId(token.key)},
			DOM.img({alt: f.alt, src: f.src}),
			DOM.figcaption({}, f.caption)
		)];
	}

	function renderPara() {
		switch (token.type) {
			case 'code':   return renderCode(token.lang);
			case 'p':      return [DOM.p({id: keyToId(token.key)}, renderSpans(token))];
			case 'header': return [DOM['h'+token.level]({id: keyToId(token.key)}, 
				fixSpaces(token.text))];
			case 'figure': return renderFigure();
			case 'ulli':   return renderList('ul', 'ulli');
			case 'olli':   return renderList('ol', 'olli');
			case 'quote':  return [DOM.blockquote({id: keyToId(token.key)}, renderSpans(token))];
			//case 'tr':     return renderTable();
			case 'table':  return [Table(token)];
			default: 
				return [
					DOM.p({className: 'error', id: keyToId(token.key)}, 
						"Error: Don't know what to do with a " + token.type)
				];
		}
	}

	function renderSection() {
		var children = [];
		getToken();
		while (token && token.type !== 'break') {
			Array.prototype.push.apply(children, renderPara());
			getToken();
		};
		return DOM.section({}, children);
	}

	while (index < tokens.length) {
		rendered.push(renderSection());
	}
	return rendered;
}

var Preview = createClass({
	render: function() {
		return DOM.div({id: 'preview', className: 'editor'}, 
			renderToFriar(this.props.model));
	}
});


var IgnoreKeys = {
	Shift: false,
	Win: false,
	Control: false,
	CapsLock: false,
	Alt: false,
	Meta: false,
	Left: true,
	Right: true,
	Up: true,
	Down: true,
};

var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
    // Opera 8.0+ (UA detection to detect Blink/v8-powered Opera)
var isFirefox = typeof InstallTrigger !== 'undefined';   // Firefox 1.0+
var isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0;
    // At least Safari 3+: "[object HTMLElementConstructor]"
var isChrome = !!window.chrome && !isOpera;              // Chrome 1+
var isIE = /*@cc_on!@*/false || !!document.documentMode; // At least IE6


var canInsertText = document.queryCommandSupported('insertText');
var canMsUndo = document.queryCommandSupported('ms-beginUndoUnit');

function insertText(ta, str) {
	if (canInsertText && !isFirefox) {
		document.execCommand('insertText', false, str);
		return;
	}
	if (canMsUndo) document.execCommand('ms-beginUndoUnit');
	var val = ta.value;
	var start = ta.selectionStart;
	var end = ta.selectionEnd;
	ta.value = val.substring(0,start) + str + val.substring(end);
	ta.selectionStart = ta.selectionEnd = start + str.length;
	if (canMsUndo) document.execCommand('ms-endUndoUnit');
}

function pathFor(node, offset, model) {
	var path = [];
	while(!node.id && node.parentNode) {
		var i = 0;
		var no = node;
		while(no = no.previousSibling) { ++i; }
		path.push(i);
		node = node.parentNode;
	}
	var id = node.id;
	if (id === 'preview') {
		//selection.node offset
		console.log(focusPath + ' from preview');
	} else if (reKey.test(id)) {
		var key = id
			.slice(KEY_PREFIX.length)
			.split('.')
			.map(function(k) { return parseInt(k, 36); });
		var ind = model.indexOfKey(key[0]);
		if (ind === -1) {
			console.log('Key not found in model ' + id);
			return;
		}
			
		var cell = model.cells[ind];
		return model.offsetOfIndex(ind) + offsetInCell(cell, path, key, offset);
	}
	return 0;
}

function offsetInCell(cell, path, key, offset) {
	switch (cell.type) {
		case 'table': 
			var rowNum = key[1] || 0;
			for (var i = 0; i < rowNum; i++) {
				offset += cell.rows[i].raw.length + 1; //+1 for newline that gets removed from raw by split
			}
			var cellNum = path.pop(); //path is now span path
			for (var i = 0; i< cellNum; i++) {
				offset += cell.rows[rowNum].cells[i].length; //change to raw length when we span cell
			}
			offset += cellNum + 1; //add on pipes
			break;
		case 'header':
			offset += cell.level;
			break;
		case 'quote':
		case 'ulli':
		case 'olli':
			offset++;
			break;
		case 'code':
			offset++;
			offset += (cell.text.slice(0,offset).match(/\n/g) || []).length; //space removed per newline
			break;

	}
	return offset;
}

function nodeAtOffset(fullOffset, model) {
	var cello = model.cellForOffset(fullOffset);
	if (!cello) return;
	var cell = cello.cell;
	var offset = cello.offset;
	var baseKey = keyToId(cell.key);
	var baseElem = document.getElementById(baseKey);
	switch (cell.type) {
		case 'table':
			var rowNum = 0;
			for (var rowNum = 0; rowNum < cell.rows.length - 1; rowNum++) {
				var l = cell.rows[rowNum].raw.length + 1;
				if (offset < l) break;
				offset -= l;
			}
			var row = cell.rows[rowNum].cells;
			var cellNum;
			offset--;
			for (cellNum = 0; cellNum < row.length - 1; cellNum++) {
				var l = row[cellNum].length + 1;
				if (offset < l) break;
				offset -= l;
			}
			if (rowNum === 0) {
				baseElem = baseElem.firstChild.firstChild; //thead.tr
			} else {
				baseElem = baseElem.childNodes[1].childNodes[rowNum-1]; //tbody.tr;
			}
			baseElem = baseElem.childNodes[cellNum].firstChild;
			break;
		case 'p':
			baseElem = baseElem.firstChild;
			break;
		case 'header':
			offset -= cell.level;
			baseElem = baseElem.firstChild;
			break;
		case 'quote':
		case 'ulli':
		case 'olli':
			offset--;
			baseElem = baseElem.firstChild;
			break;
		case 'code':
			offset--;
			offset -= (cell.text.slice(0,offset).match(/\n/g) || []).length; //space removed per newline
			baseElem = baseElem.firstChild;
			break;
	}
	return {node: baseElem, offset: offset};
}

function childOfId(node, id) {
	do {
		if (node.id == id) return true;
	} while (node = node.parentNode);
	return false;
}


var Selection = createClass({
	getInitialState: function() {
		return {
			selection: null,
		}
	},
	renderSelection: function(range) {
		var rects = range.getClientRects(),
			r = range.getBoundingClientRect()
		  , ret = []
		  , cs
		  , fbot
		  , rect
		  , farLeft = Math.floor(r.left)
		  , farRight = Math.ceil(r.right)
		  , scrollTop = document.documentElement.scrollTop || document.body.scrollTop
          , scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft
          , len = rects.length
          , i;
        if (len > 0) {
        	rect = rects[0];
        	cs = {
        		top: (rect.top + scrollTop) + 'px',
        		left: (rect.left + scrollLeft) + 'px',
        		height: rect.height + 'px',
        		width: (farRight - rect.left) + 'px',
        	}
			fbot = rect.bottom;
        	ret.push(DOM.div({style:cs, key:'first'}," "));
        }
        if (len > 1) {
        	rect = rects[len - 1];
        	cs = {
        		left: (farLeft + scrollLeft) + 'px',
        		width: (rect.right - farLeft) + 'px',
        	}
			var gap = rect.top - fbot;
			if (gap < rect.height * 0.6) {
				cs.top = (rect.top + scrollTop - gap) + 'px';
        		cs.height = (rect.height + gap) + 'px';
			} else {
        		cs.top = (rect.top + scrollTop) + 'px';
        		cs.height = rect.height + 'px';
        		// now draw the gap
        		ret.push(DOM.div({style: {
        			top: (fbot + scrollTop) + 'px',
        			left: (farLeft + scrollLeft) + 'px',
        			width: (farRight - farLeft) + 'px',
        			height: gap + 'px'
        		}, key: 'mid'}, " "));
			}
			ret.push(DOM.div({style: cs, key: 'last'}, " "));
        }
        return ret;
	},
	render: function() {
		var range = this.state.selection;
		if (range === null)
			return DOM.div({id: 'selection'});

		var rects = range.getClientRects(),
			scrollTop = document.documentElement.scrollTop || document.body.scrollTop,
        	scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
        if (rects.length === 0)
        	return DOM.div({id: 'selection'});


		if (range.collapsed) {
			var rect = rects[0];
			var cs = {
				top: (rect.top + scrollTop) + 'px',
				left: (rect.right + scrollLeft - 1) + 'px',
				height: rect.height + 'px',
				display: 'block',
			}
			return DOM.div({id: 'selection'}, [DOM.span({className: 'cursor', style: cs},' ')]);
		} else {
			return DOM.div({id: 'selection', className: 'selection'}, this.renderSelection(range)); //draw divs
		}
		
	},
});


var Editor = createClass({
	getInitialState: function() {
		var text = this.props.text;
		return {
			text: text,
			selection: { focus: 0, anchor: 0 },
			model: new Model(parse(text)),
		};
	},
	updateText: function() {
		if (this.dontUpdate) return;
		
		var ta = this.textarea.node;
		console.log('updateText at ' + ta.selectionStart + ':' + ta.selectionEnd);
		
		var ta = this.textarea.node;
		var cur = this.state.selection;
		var text = ta.value;
		var hasTextChanged = (text != this.state.text);
		var hasSelectionChanged = !(ta.selectionStart == cur.anchor &&
			ta.selectionEnd == cur.focus)

		if (hasTextChanged && hasSelectionChanged) {
			this.setState({
				text: text, 
				model: this.state.model.merge(parse(text)),
				selection: {anchor: ta.selectionStart, focus: ta.selectionEnd},
			});
		} else if (hasSelectionChanged) {
			this.setState({
				selection: {anchor: ta.selectionStart, focus: ta.selectionEnd},
			});
		} else if (hasTextChanged) {
			this.setState({
				text: text, 
				model: this.state.model.merge(parse(text))
			});
		}
	},
	handleMouseUp: function(e) {
		var selected = window.getSelection();
		if (selected.rangeCount !== 1)
			return;
		if (!childOfId(selected.anchorNode, 'preview') ||
			!childOfId(selected.focusNode, 'preview')) return;
		var range = selected.getRangeAt(0);
		var focus = pathFor(selected.focusNode, selected.focusOffset, this.state.model);
		var anchor = focus;
		if (!selected.isCollapsed) {
			anchor = pathFor(selected.anchorNode, selected.anchorOffset, this.state.model);
		}
		//check roundTrip
		var x = nodeAtOffset(focus, this.state.model);
		if (x && (x.node !== selected.focusNode || x.offset !== selected.focusOffset)) {
			console.log('WARNING: selection not round tripping');
			console.log(x);
			console.log({node: selected.focusNode, offset: selected.focusOffset});
		}
		
		//var ta = this.textarea.node;
		var cur = this.state.selection;
		if (anchor !== cur.anchor || focus !== cur.focus) {
			this.setState({selection: {anchor: anchor, focus: focus}});
		}
		if (anchor === focus) {
			this.dontUpdate = true;
			var ta = this.textarea.node;
			ta.focus();
			if (ta.setSelectionRange) ta.setSelectionRange(anchor, focus);
			this.dontUpdate = false;
		}
		console.log('up ' + anchor + ' to ' + focus);
		
	},
	handleChange: function(e) {
		console.log('change');
		this.updateText();
	},
	handleKeyDown: function(e) {
		console.log('keydown');
		this.updateText();
	},
	handleKeyUp: function(e) {
		console.log('keyup');
		this.updateText();
	},
	handleFocus: function(e) {
		console.log('focus');
		this.updateText();
	},
	handleBlur: function(e) {
		console.log('blur');
		this.updateText();
	},
	handleInput: function(e) {
		console.log('input');
		this.updateText();
	},
	handleContentKeyDown: function(e) {
		//Ignore movement keys...
		var key = e.key || e.keyIdentifier;
		if (IgnoreKeys.hasOwnProperty(key)
			&& (!IgnoreKeys[key]
			||e.ctrlKey||e.shiftKey||e.altKey||e.metaKey)) {
			this.handleMouseUp(e);
			return;
		}
		//console.log(key);
		var ta = this.textarea.node;
		var cur = this.state.selection;
		this.blur = document.activeElement !== ta;
		if (this.blur) {
			this.dontUpdate = true;
			ta.focus();
			if (ta.setSelectionRange) {
				if (cur.anchor <= cur.focus)
					ta.setSelectionRange(cur.anchor, cur.focus);
				else
					ta.setSelectionRange(cur.focus, cur.anchor);
			}
			this.dontUpdate = false;
		}
		
		//

		// if (e.keyCode === 13) {
		// 	var val = this.textarea.node.value;
		// 	var start = this.textarea.node.selectionStart;
		// 	var lineStart = val.lastIndexOf('\n',start-1) + 1;
		// 	var cap = val.slice(lineStart,lineStart+1);
		//  	if (cap === '.' || cap === ' ' || cap === '*') {
		//  		insertText(this.textarea.node, '\n' + cap);
		//  		e.preventDefault();
		// 	}
		// }
	},
	handleContentKeyUp: function(e) {
		/*if (this.blur) {
			this.dontUpdate = true;
			this.textarea.node.blur();
			this.blur = false;
			this.dontUpdate = false;
		}*/
	},
	didMount: function() {
		console.log('mounted');
		//TODO: this stuff should be on the actual textarea node itself
		document.body.addEventListener('keydown', this.handleContentKeyDown);
		document.body.addEventListener('keyup', this.handleContentKeyUp);
		this.textarea.node.value = this.state.text;
		this.textarea.node.selectionStart = this.textarea.selectionEnd = 0;
	},
	updateCursor: function() {
		var sel = this.state.selection;
		var anchor, focus;
		var range = document.createRange();
		anchor = focus = nodeAtOffset(sel.focus, this.state.model);
		if (sel.focus !== sel.anchor) {
			anchor = nodeAtOffset(sel.anchor, this.state.model);
		}

		try {
			if (anchor.offset < 0) {
				range.setStartBefore(anchor.node);
			} else {
				range.setStart(anchor.node, anchor.offset);
			}

			if (focus.offset < 0) {
				range.setEndBefore(focus.node);
			} else {
				range.setEnd(focus.node, focus.offset);
			}
		} catch(e) {
			console.log('Invalid range');
		}

		var rects = range.getClientRects(),
			scrollTop = document.documentElement.scrollTop || document.body.scrollTop,
        	scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
        if (rects.length > 0) {
        	var rect = rects[0];
        	this.textarea.node.style.top = (rect.top + 5 + scrollTop) + 'px';
        }

		this.selection.setState({selection: range});


	},
	didUpdate: function() {
		console.log('updated');
		//console.log(this.selection);
		//TODO: set the selection and cursor positions.
		this.updateCursor(); 
		
	},
	willUnmount: function() {
		console.log('unmounting');
	},
	render: function() {
		console.log('render');
		//?? does this work when we are going with previous Child and updating
		this.textarea = DOM.textarea({
			id: 'model', 
			className: 'hiddenTextArea', 
			//value: this.state.text,
			onKeyDown: this.handleKeyDown,
			onKeyUp: this.handleKeyUp,
			onFocus: this.handleFocus,
			onBlur: this.handleBlur,
			onChange: this.handleChange,
			onInput: this.handleInput,
		});
		this.selection = Selection();
		return DOM.div({
				className: 'content',
				onMouseUp: this.handleMouseUp,
			},
			this.textarea, 
			this.selection, 
			Preview({model: this.state.model})
			);
	}
});

var text = "#Cube\n"
		 + "This is a paragraph\n"
		 + "|this|is|a|table\n"
		 + "|more|table|stuff|here\n"
		 + "This is another paragraph & stuff\n"
		 + " Month[] = {Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec}\n"
		 + "Some description here\n"
		 + " This is a line that has a continued line after it\n"
		 + "  this is the continued line here\n"
		 + " function something() {\n"
		 + "   //this is some javascript that gets automatically detected.\n"
		 + " }\n"
		 + " This is some code after the javascript\n"
		 + "This is a paragraph\n"
		 + "*This is a list item\n"
		 + "*this is another list item\n"
		 + ".This is a numbered list item\n"
		 + ".This is another numbered list item\n"
		 + "This is another paragraph\n"
		 + "##This is a sub header\n"
		 + "This is a paragraph with *bold* text and _italic_ text in it\n"
		 + "This is a paragraph with a link [this is link text][1].\n"
		 + ">This is a blockquote\n"
		 + "-"
		 + "The dash before a paragraph is a section break (that might be rendered as an hr - note.. change so it doesn't need to be on its own line but can live before a paragraph or other element)\n"
		 + "![alt text](css/fonts/glyphicons-halflings.png)figure text here\n"
		 + "Idea ... use non printing characters to stand in for bold and italics and links in the code so that you don't have extra characters to delete or insert in those cases. This might not help much. It might be easier to just store the list and manage it based on keypresses.\n"
		 + "There is an empty paragraph at the end after this one. âŠ•\n"
		 + "\n"
		 + "[1](http://google.co.uk \"Google\")\n";

var x;
Friar.renderComponent(x = new Editor({text: text}), document.getElementById('main'));

/*
var O = {}
var A = O.A = function() { return 10; }
var B = O.B = function() { return 11; }
var C = O.C = function() { return 12; }

function Plus(a, b) { 
	return function() {	return a() + b(); };
}

O.Clo = Plus(Plus(O.A,O.B),O.C);
O.Fun = (new Function(['a','b','c'],
 'return function() { return (a() + b()) + c(); };'))(O.A,O.B,O.C); //if we do the full 
O.FunI = new Function('var me = this; return (me.A() + me.B()) + me.C()');
O.FunII = (new Function(['Ob'],
	'var A = Ob.A, B = Ob.B, C = Ob.C; return function () { return (A() + B()) + C(); };'))(O);
O.Eval = eval('(function() { return A() + B() + D(); })');


function D() { return 12; }

console.log(O.Clo());
console.log(O.Fun());
console.log(O.FunI());
console.log(O.FunII());
console.log(O.Eval());

function test(n) {
	console.time('Clo');
	for (var i = 0; i < n; i++) O.Clo();
	console.timeEnd('Clo');
	
	console.time('Fun');
	for (var i = 0; i < n; i++) O.Fun();
	console.timeEnd('Fun');

	console.time('FunI');
	for (var i = 0; i < n; i++) O.FunI();
	console.timeEnd('FunI');

	console.time('FunII');
	for (var i = 0; i < n; i++) O.FunII();
	console.timeEnd('FunII');

	console.time('Eval');
	for (var i = 0; i < n; i++) O.Eval();
	console.timeEnd('Eval');
}
*/

</script>
</body>
</html>